# R Graphics with ggplot2
# Fall 2015
# UVa StatLab
# Clay Ford


# Helpful R Studio commands -----------------------------------------------

# Description       Windows & Linux       Mac 
# ----------------------------------------------------------------
# Run current line  Ctrl+Enter            Command+Enter
# Previous plot     Ctrl+Shift+PageUp     Command+Shift+PageUp 
# Next plot 	      Ctrl+Shift+PageDown 	Command+Shift+PageDown 


# Packages ----------------------------------------------------------------

# we'll use the following packages today.
# only submit these lines if you don't already have these packages installed. 
install.packages("ggplot2")
install.packages("gridExtra")

library(ggplot2)


# Data --------------------------------------------------------------------

# Charlottesville home data
# Downloaded from Office of Geographic Data Services, 15-Sept-2015

# Primary Card Level Data - this file includes data such as year built, 
# finished square footage, number of rooms, and condition.
# http://www.albemarle.org/gds/gisdata/CAMA/CAMA_CardLevelData_TXT.zip

# merged with...

# Real Estate Information - Parcel Level Data.  This file contains information
# about the parcel itself such as assessed value
# http://www.albemarle.org/gds/gisdata/CAMA/CAMA_ParcelInfo_TXT.zip

url1 <- "http://people.virginia.edu/~jcf2d/workshops/ggplot2/cville_real_estate.csv"
homes <- read.csv(url1)

str(homes)


# One Variable ------------------------------------------------------------

# The histogram helps us see how a continous variable is distributed
ggplot(homes, aes(x=FinSqFt)) + geom_histogram()

# not the message regarding "stat_bin"
# Recal "stat_bin" is the stat for geom_histogram
# What is range/30?
diff(range(homes$FinSqFt))/30

# with a new binwidth
ggplot(homes, aes(x=FinSqFt)) + geom_histogram(binwidth=250)
# try some others!

# what if we want a "True" Histogram with density instead of count?
ggplot(homes, aes(x=FinSqFt)) + 
  geom_histogram(aes(y=..density..), binwidth=250)

# ..density.. is avariable generated by stat_bin; documented on the stat_bin
# page

# Before we go further, important to note we can save a plot object and add to
# it:
p <- ggplot(homes, aes(x=FinSqFt))
p + geom_histogram(binwidth=300)

# Let's try a new geom with p, geom_density()
p + geom_density()
# combine density and histogram
p + geom_histogram(aes(y=..density..), binwidth=300) + geom_density(color="red")

# we can make overlayed histograms with transparency
ggplot(homes, aes(x=FinSqFt, fill=Condition)) + 
  geom_histogram(position = "identity", alpha=0.4, binwidth=250)
# position="identity" needed for overlapping; without they get stacked;
# alpha = transparency setting

# probably better with fewer categories
# the scale function manually orders the legend
ggplot(subset(homes, Condition %in% c("Excellent","Good","Average")), 
       aes(x=FinSqFt, fill=Condition)) + 
  geom_histogram(position = "identity", alpha=0.4, binwidth=250) 



####################################
# YOUR TURN! Create a histogram of TotalValue, the total value of the home.
# What's a good bandwidth?
ggplot(homes, aes(x=TotalValue)) + geom_histogram(binwidth = 50000)

####################################

# Bar Plots help us visualize how discrete values are distributed:
ggplot(homes, aes(x=Condition)) + geom_bar()

# Use a scales function to re-order x-axis
ggplot(homes, aes(x=Condition)) + geom_bar() +
  scale_x_discrete(limits=c("Excellent","Good","Average","Fair","Poor","Substandard"))


# What happens when we combine other aesthetics with bar plots?
# For example, map the Remodeled indicator to color;
# Note: we need to declare it as a "factor"
ggplot(homes, aes(x=Condition, fill=factor(Remodeled))) + geom_bar()

# Note the "stacked" position. We can change that with the position argument:
ggplot(homes, aes(x=Condition, fill=factor(Remodeled))) + 
  geom_bar(position = "dodge")

# How can we fix the legend title?
# Recall that is a by-product of the scale. So we need to use a scale function.
ggplot(homes, aes(x=Condition, fill=factor(Remodeled))) + 
  geom_bar(position = "dodge") +
  scale_fill_discrete(name="Remodeled")

# By default, the stat for geom_bar (stat_bin) counts up things in your data
# frame. What if you already have counts? Use the "identity" stat and map value
# to y aesthetic.
remod <- as.data.frame(table(homes$Remodeled))
class(remod)
remod

p2 <- ggplot(remod, aes(x=Var1, y=Freq)) + 
  geom_bar(stat="identity", width=0.5)
p2

# we can fix it up...
p2 + scale_x_discrete(labels=c("Original","Remodeled")) +
  labs(x=NULL, y="Number of Homes", 
       title="Number of remodeled versus original homes in Charlottesville")


# Two variables -----------------------------------------------------------

# The scatterplot allows you to visualize the relationship between two
# continuous variables.

# plot FinSqFt vs TotalValue:
ggplot(homes, aes(x=FinSqFt, y=TotalValue)) + geom_point()

# Lots of overplotting!
# we could take a random sample of homes, say 1000.
homesSample <- homes[sample(nrow(homes),1000),]
ggplot(homesSample, aes(x=FinSqFt, y=TotalValue)) + geom_point()

# What else can we do about the overplotting? One solution is the alpha
# aesthetic. "alpha=1/10" means 10 points overplotted adds to a solid color
ggplot(homes, aes(x=FinSqFt, y=TotalValue)) + geom_point(alpha=1/10)

# Can also try smaller points using the shape aesthetic
ggplot(homes, aes(x=FinSqFt, y=TotalValue)) + geom_point(shape=".")

# Notice we can set an aesthetic property to a single value instead of
# mapping it to a variable. 


# Another approach is to use facets: break the data into subsets 
ggplot(homes, aes(x=FinSqFt, y=TotalValue)) + geom_point() +
  facet_wrap(~ Condition)

# Maybe let the scales vary? 
ggplot(homes, aes(x=FinSqFt, y=TotalValue)) + geom_point() +
  facet_wrap(~ Condition, scales = "free")

# and we can combine our tactics
p3 <- ggplot(homes, aes(x=FinSqFt, y=TotalValue)) + 
  geom_point(alpha=1/6) +
  facet_wrap(~ Condition)
p3


#################################### 
# YOUR TURN! Plot FinSqFt vs. YearBuilt. Put FinSqFt on the y axis. Facet by
# Condition. Perhaps try an alpha setting?
ggplot(homes, aes(x=YearBuilt, y=FinSqFt)) + geom_point(alpha=1/8) +
  facet_wrap(~ Condition)


####################################

# Look again at our p3 plot:
p3
# The y-axis scale would look better formatted as dollar amounts. The scales
# package can help with this. It has functions designed for this type of
# situation. When you install ggplot2, scales is installed as well.
library(scales)
p3 <- p3 + scale_y_continuous(labels=dollar) + scale_x_continuous(labels=comma)
p3
# We can add a smooth line through our scatterplots with geom_smooth()
p3 + geom_smooth()
# yikes, lots of warnings, probably due to Substandard only have 3 obs;
# let's just try fitting a straight linear regression line
p3 + geom_smooth(method="lm")
p3 + geom_smooth(method="lm", se=F)

# we can also specify our own formula
p3 + geom_smooth(method="lm", se=F, formula= y ~ poly(x,2))


# Log Transformations in scatter plots

# Dollar amounts are often log transformed. Maybe try log base 10 transformation
# directly:
ggplot(homes, aes(x=log10(FinSqFt), y=log10(TotalValue))) + geom_point()

# can use scale functions to both transform data and map scales to original data
# space:
ggplot(homes, aes(x=FinSqFt, y=TotalValue)) + geom_point() +
  scale_x_log10() + scale_y_log10()

# getting fancy using more scales functions...
ggplot(homes, aes(x=FinSqFt, y=TotalValue)) + geom_point() +
  scale_x_log10(breaks = trans_breaks("log10", function(x) 10^x),
                labels = trans_format("log10", math_format(10^.x))) + 
  scale_y_log10(breaks = trans_breaks("log10", function(x) 10^x),
                labels = trans_format("log10", math_format(10^.x)))


# Boxplots are good for visualizing a continous variable conditional on a
# discrete variable. Let's look at TotalValue by number of FullBaths:

ggplot(homes, aes(x=FullBath,y=TotalValue)) + geom_boxplot()
# oops. FullBath is not discrete. This works.
p4 <- ggplot(homes, aes(x=factor(FullBath),y=TotalValue))
p4 + geom_boxplot()

p4 + geom_boxplot() + scale_y_continuous(labels=dollar)
# $9,000,000 homes with only two full baths?

p4 + geom_boxplot() + scale_y_continuous(labels=dollar) + 
  facet_wrap(~Condition) + labs(x = "Number of Full Baths")

# Just look at homes under $1,000,000
ggplot(subset(homes, TotalValue < 1e6), 
       aes(x=factor(FullBath),y=TotalValue)) + 
  geom_boxplot() + scale_y_continuous(labels=dollar)

####################################
# YOUR TURN! Make a boxplot of FinSqFt by HalfBath. 
ggplot(homes, aes(x=factor(HalfBath), y=FinSqFt)) + geom_boxplot() +
  scale_y_continuous(labels=comma)



####################################

# A nice alternative to boxplots are stripcharts. Basically plot a 1d 
# scatterplot for each level of the discrete value. Works well for smaller data
# sets.

# 0 bedroom houses (?)
homes0 <- subset(homes, Bedroom==0)

# plot total value per Number of Full Baths
ggplot(homes0, aes(x=factor(FullBath), y=TotalValue)) + 
  geom_point(position = position_jitter(w = 0.1, h = 0)) +
  scale_y_continuous(labels=dollar)
# position_jitter(w = 0.1, h = 0) means jitter points left-and-right but not
# up-and-down.


# How about plotting two "discrete" integer variables?
# Bedroom vs. FullBath
ggplot(homes, aes(x=Bedroom,y=FullBath)) + geom_point()

# geom_jitter() can help with this
ggplot(homes, aes(x=Bedroom,y=FullBath)) + geom_jitter()

# scales could be better...
ggplot(homes, aes(x=Bedroom,y=FullBath)) + geom_jitter() +
  scale_x_continuous(breaks=0:16, minor_breaks=NULL) +
  scale_y_continuous(breaks=0:12, minor_breaks=NULL)
  

# line graphs are nice for connecting dots and showing a trend over time.

# plot number of houses built per year
years <- as.data.frame(table(homes$YearBuilt, dnn="YearBuilt"), 
                           stringsAsFactors = FALSE)
str(years)
years$YearBuilt <- as.numeric(years$YearBuilt)

# now use geom_line()
ggplot(years, aes(x=YearBuilt, y=Freq)) + geom_line()

# again we can touch up the scales and labels
ggplot(years, aes(x=YearBuilt, y=Freq)) + geom_line() +
  scale_x_continuous(breaks=seq(1700,2000,50)) +
  labs(x="Year",y="Number of Homes")

# what year was the spike?
subset(years, Freq > 800)

# Multiple plots in one window --------------------------------------------


# In base R, we usually use par(mfrow=c(i,j)), like so:
par(mfrow=c(1,2))
hist(homes$FinSqFt)
plot(FinSqFt ~ YearBuilt, data=homes)
par(mfrow=c(1,1))

# We cannot use this approach for ggplot2. The easiest solution is to use the 
# grid.arrange() function in the gridExtra package. To use it, you have to save
# your plots and then call them using grid.arrange().

p1 <- ggplot(homes, aes(x=FinSqFt)) + geom_histogram() 
p2 <- ggplot(homes, aes(x=YearBuilt, y=FinSqFt)) + geom_point()
library(gridExtra)
grid.arrange(p1, p2, nrow=1) # can also use ncol


# Miscellaneous Topics ----------------------------------------------------

# "zoom in" on plot with coord_cartesian()
ggplot(homes, aes(x=FinSqFt, y=TotalValue)) + geom_point()

# zoom in on houses with 2000 to 3000 FinSqFt and value between $200,000 and
# $400,000
ggplot(homes, aes(x=FinSqFt, y=TotalValue)) + geom_point() +
  coord_cartesian(xlim=c(2000,3000),c(200000,400000))


# add means to boxplots

# add mean to iris box plots
bp <- ggplot(iris, aes(x=Species, y=Petal.Width)) + geom_boxplot(width=0.5)
bp
# now add means to the plot using stat_summary():
bp + stat_summary(fun.y = mean, geom="point", color="red", size=3)

# add means and CIs to strip chart

# first need to calculate means and standard errors
fMean <- tapply(chickwts$weight, chickwts$feed, mean)
fSE <- tapply(chickwts$weight, chickwts$feed, function(x) sd(x)/sqrt(length(x)))
# now create data frame; recall that ggplot requires data frame
chick2 <- data.frame(feed=names(fMean), fMean, fSE, row.names = NULL)

# now plot strip chart and error bars
# notice we call two data frames
sc <- ggplot(chickwts, aes(x=feed, y=weight)) + 
  geom_point(position = position_jitter(w = 0.1, h = 0))
sc

# now add mean and error bars
sc + geom_point(data=chick2, aes(x=feed, y=fMean), color="#0D3268", size=3) +
  geom_errorbar(data=chick2, aes(x=feed, y=fMean, 
                                 ymin=fMean - 2*fSE, 
                                 ymax=fMean + 2*fSE), 
                width=0.1, color="#F59A2C") +
  labs(title="Mean Weight by Feed Type with 2*SE Bars")

# another way using stat_summary; fun.data="mean_cl_normal" actually calls the 
# function smean.cl.normal() from the Hmisc package. It uses the t distribution
# to determine the multiplier of the standard error.
ggplot(chickwts, aes(x=feed, y=weight)) + 
  geom_point(position = position_jitter(w = 0.1, h = 0)) +
  stat_summary(fun.data="mean_cl_normal", color="#F59A2C", geom="errorbar", width=0.1) +
  stat_summary(fun.y = mean, geom="point", color="#0D3268", size=3)


# single line graph of means at each time point with SE bars

# Indometh data (comes with R)
# Six subjects were given an intravenous injection of indometacin at 11 times,
# and each time plasma concentrations of indometacin was measured.

# Here we make a line plot for each subject:
ggplot(Indometh, aes(x=time,y=conc, group=Subject)) +
  geom_line()

# Let's say we wanted to create a single line graph of means at each time point
# with SE bars.

# first calculate means and SEs
tMean <- tapply(Indometh$conc, Indometh$time, mean)
tSE <- tapply(Indometh$conc, Indometh$time, function(x)sd(x)/sqrt(length(x)))

# ggplot requires data in data frame
Indo2 <- data.frame(time=unique(Indometh$time), tMean, tSE, row.names = NULL)

# now ready to create plot
ggplot(Indo2, aes(x=time,y=tMean)) +
  geom_line() +
  geom_errorbar(aes(ymin=tMean-2*tSE, ymax=tMean+2*tSE), width=0.1)

# or again we can use stat_summary()
ggplot(Indometh, aes(x=time,y=conc)) +
  stat_summary(fun.data="mean_cl_normal", geom="errorbar", width=0.1) +
  stat_summary(fun.y = mean, geom="line")


# maps
# ggplot can plot maps

# The following data are occurences of cougars in the US. It was downloaded from
# Biodiversity Information Serving Our Nation (BISON),
# http://bison.usgs.ornl.gov.

url <- "http://people.virginia.edu/~jcf2d/workshops/ggplot2/bison-Cougar-20150520-172801.csv"
cougar <- read.csv(url)

install.packages("maps")
install.packages("mapproj")

library(maps)
library(mapproj) # for the "polyconic" option

# Let's plot a map that shows occurences of courgars in the US and the type of occurence.

# first create a data frame of map data; "state" is the name of a map provided
# by the maps package.
states <- map_data("state")
# rename providedState to "region and make lower case for purposes of merging
cougar$region <- tolower(cougar$providedState)
# merge states and courgar data frames by region
cougmap <- merge(states, subset(cougar, !is.na(decimalLongitude)), by = "region")

# now we're ready to plot! Map longitude and latitude to x and y aesthetics;
# The borders function draws the state borders;
# the coord_map("polyconic") function makes the map look curvy, like a globe;
# Give it a second...
ggplot(cougmap, aes(x=long, y=lat)) +
  borders("state") +
  geom_point(aes(x = decimalLongitude, y=decimalLatitude, color=basisOfRecord)) +
  coord_map("polyconic")


# saving graphs as images

# use ggsave(). It saves the last plot according to your file extension.
ggsave("cougars.jpg", width=10, height=5)

# Themes

# Using built-in themes such as theme_bw()
# Before
ggplot(airquality, aes(x=Temp)) + geom_histogram(binwidth=2) +
  facet_wrap(~Month)
# After
ggplot(airquality, aes(x=Temp)) + geom_histogram(binwidth=2) +
  facet_wrap(~Month) + theme_bw()

# To permanently change the theme:
prevTheme <- theme_set(theme_bw())

ggplot(airquality, aes(x=Temp)) + geom_histogram(binwidth=2) +
  facet_wrap(~Month)

ggplot(airquality, aes(x=Temp)) + geom_freqpoly(binwidth=2) +
  facet_wrap(~Month)

# To restore
theme_set(prevTheme)
# verify
ggplot(airquality, aes(x=Temp)) + geom_freqpoly(binwidth=2) +
  facet_wrap(~Month)






