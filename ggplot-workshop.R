# R Graphics with ggplot2
# Fall 2015
# UVa StatLab
# Clay Ford


# Helpful R Studio commands -----------------------------------------------

# Description       Windows & Linux       Mac 
# ----------------------------------------------------------------
# Run current line  Ctrl+Enter            Command+Enter
# Previous plot     Ctrl+Shift+PageUp     Command+Shift+PageUp 
# Next plot 	      Ctrl+Shift+PageDown 	Command+Shift+PageDown 


# Packages ----------------------------------------------------------------

# we'll use the following packages today.
# only submit these lines if you don't already have these packages installed. 
install.packages("ggplot2")
install.packages("reshape2")
install.packages("scales")
install.packages("maps")
install.packages("mapproj")

library(ggplot2)


# Data --------------------------------------------------------------------

# Charlottesville home data
# Downloaded from Office of Geographic Data Services, 15-Sept-2015

# Primary Card Level Data - this file includes data such as year built, 
# finished square footage, number of rooms, and condition.
# http://www.albemarle.org/gds/gisdata/CAMA/CAMA_CardLevelData_TXT.zip

# merged with...

# Real Estate Information - Parcel Level Data.  This file contains information
# about the parcel itself such as owner information, deed acreage value, and
# assessed value
# http://www.albemarle.org/gds/gisdata/CAMA/CAMA_ParcelInfo_TXT.zip


homes <- read.csv("data/cville_real_estate.csv")
homes <- read.csv("URL")
str(homes)


# One Variable ------------------------------------------------------------

# The histogram helps us see how a continous variable is distributed
ggplot(homes, aes(x=FinSqFt)) + geom_histogram()

# not the message regarding "stat_bin"
# Recal "stat_bin" is the stat for geom_histogram
# What is range/30?
diff(range(homes$FinSqFt))/30

# with a new binwidth
ggplot(homes, aes(x=FinSqFt)) + geom_histogram(binwidth=250)
# try some others!

# what if we want a "True" Histogram with density instead of count?
ggplot(homes, aes(x=FinSqFt)) + 
  geom_histogram(aes(y=..density..), binwidth=250)

# ..density.. is avariable generated by stat_bin; documented on the stat_bin
# page

# Before we go further, important to note we can save a plot object and add to
# it:
p <- ggplot(homes, aes(x=FinSqFt))
p + geom_histogram(binwidth=300)

# Let's try a new geom with p, geom_density()
p + geom_density()
# combine density and histogram
p + geom_histogram(aes(y=..density..), binwidth=300) + geom_density(color="red")

# YOUR TURN! Create a histogram of TotalValue, the total value of the home.
# What's a good bandwidth?




# Bar Plots help us visualize how discrete values are distributed:
ggplot(homes, aes(x=Condition)) + geom_bar()

# What happens when we combine other aesthetics with bar plots?
# For example, map the Remodeled indicator to color;
# Note: we need to declare it as a "factor"
ggplot(homes, aes(x=Condition, fill=factor(Remodeled))) + geom_bar()

# Note the "stacked" position. We can change that with the position argument:
ggplot(homes, aes(x=Condition, fill=factor(Remodeled))) + 
  geom_bar(position = "dodge")

# How can we fix the legend title?
# Recall that is a by-product of the scale. So we need to use a scale function.
ggplot(homes, aes(x=Condition, fill=factor(Remodeled))) + 
  geom_bar(position = "dodge") +
  scale_fill_discrete(name="Remodeled")

# By default, the stat for geom_barplot (stat_bin) counts up things in your data
# frame. What if you already have counts? Use the "identity" stat and map value
# to y aesthetic.
remod <- as.data.frame(table(homes$Remodeled))
class(remod)
remod

p2 <- ggplot(remod, aes(x=Var1, y=Freq)) + 
  geom_bar(stat="identity", width=0.5)
p2

# we can fix it up...
p2 + scale_x_discrete(labels=c("Original","Remodeled")) +
  labs(x=NULL, y="Number of Homes", 
       title="Number of remodeled versus original homes in Charlottesville")


# Dot plots are a reasonable substitute for bar plots. They use "less ink".
condition <- as.data.frame(table(homes$Condition, dnn = "Condition"))
condition

ggplot(condition, aes(x=Freq, y=Condition)) + geom_point()
# reorder x-axis by Freq, add axis labels
ggplot(condition, aes(x=Freq, y=reorder(Condition, Freq))) + 
  geom_point() + labs(x="Number of Houses", y="Condition")


# Two variables -----------------------------------------------------------

# The scatterplot allows you to visualize the relationship between two
# continuous variables.

# plot FinSqFt vs TotalValue:
ggplot(homes, aes(x=FinSqFt, y=TotalValue)) + geom_point()

# Lots of overplotting!
# Perhaps look at homes after 1900
# make sure new data set is a data frame; subset is good for this
homes1900 <- subset(homes, YearBuilt > 1900)
class(homes1900) # yep, it's a data frame!
ggplot(homes1900, aes(x=FinSqFt, y=TotalValue)) + geom_point()

# we could also take a random sample of homes, say 1000.
set.seed(10)
homesSample <- homes[sample(nrow(homes),1000),]
ggplot(homesSample, aes(x=FinSqFt, y=TotalValue)) + geom_point()

# What else can we do about the overplotting? One solution is the alpha
# aesthetic. "alpha=1/10" means 10 points overplotted adds to a solid color
ggplot(homes, aes(x=FinSqFt, y=TotalValue)) + geom_point(alpha=1/10)

# Can also try smaller points using the shape aesthetic
ggplot(homes, aes(x=FinSqFt, y=TotalValue)) + geom_point(shape=".")

# Notice we can set an aesthetic property to a single value instead of
# mapping it to a variable. 

# Another approach is to use facets: break the data into subsets 
ggplot(homes, aes(x=FinSqFt, y=TotalValue)) + geom_point() +
  facet_wrap(~ Condition)

# Maybe let the scales vary? 
ggplot(homes, aes(x=FinSqFt, y=TotalValue)) + geom_point() +
  facet_wrap(~ Condition, scales = "free")

# and we can combine our tactics
p3 <- ggplot(homes1900, aes(x=FinSqFt, y=TotalValue)) + 
  geom_point(alpha=1/6) +
  facet_wrap(~ Condition)
p3

# YOUR TURN! Plot FinSqFt vs. YearBuilt. Put FinSqFt on the y axis. Use the
# full homes data set. Facet by Condition. Perhaps try an alpha setting?
ggplot(homes, aes(x=YearBuilt, y=FinSqFt)) + geom_point(alpha=1/8) +
  facet_wrap(~ Condition)


# Look again at our p3 plot:
p3
# The y-axis scale would look better formatted as dollar amounts. The scales
# package can help with this. It has functions designed for this type of
# situation. For example:
library(scales)
p3 <- p3 + scale_y_continuous(labels=dollar)
p3
# We can add a smooth line through our scatterplots with geom_smooth()
p3 + geom_smooth()
# yikes, lots of warnings, probably due to Substandard only have 3 obs;
# let's just try fitting a straight linear regression line
p3 + geom_smooth(method="lm")
p3 + geom_smooth(method="lm", se=F)


# Boxplots are good for visualizing a continous variable conditional on a
# discrete variable. Let's look at TotalValue by number of FullBaths:

ggplot(homes, aes(x=FullBath,y=TotalValue)) + geom_boxplot()
# oops. FullBath is not discrete. This works.
p4 <- ggplot(homes, aes(x=factor(FullBath),y=TotalValue))
p4 + geom_boxplot()

p4 + geom_boxplot() + scale_y_continuous(labels=dollar)
# $9,000,000 homes with only two full baths?

p4 + geom_boxplot() + scale_y_continuous(labels=dollar) + 
  facet_wrap(~Condition) + labs(x = "Number of Full Baths")

# Just look at homes under $1,000,000
ggplot(subset(homes, TotalValue < 1e6), 
       aes(x=factor(FullBath),y=TotalValue)) + 
  geom_boxplot() + scale_y_continuous(labels=dollar)

# YOUR TURN! Make a boxplot of FinSqFt by HalfBath. 
ggplot(homes, aes(x=factor(HalfBath), y=FinSqFt)) + geom_boxplot() +
  scale_y_continuous(labels=comma)

# A nice alternative to boxplots are stripcharts. Basically plot a 1d 
# scatterplot for each level of the discrete value. Works well for smaller data
# sets.

# 0 bedroom houses
homes0 <- subset(homes, Bedroom==0)

# plot total value per Number of Full Baths
ggplot(homes0, aes(x=factor(FullBath), y=TotalValue)) + 
  geom_point(position = position_jitter(w = 0.1, h = 0)) +
  scale_y_continuous(labels=dollar)
# position_jitter(w = 0.1, h = 0) means jitter points left-and-right but not
# up-and-down.


# How about plotting two discrete (ie, integer) variables?
# Bedroom vs. FullBath
ggplot(homes, aes(x=Bedroom,y=FullBath)) + geom_point()

# geom_jitter() can help with this
ggplot(homes, aes(x=Bedroom,y=FullBath)) + geom_jitter()

# scales could be better...
ggplot(homes, aes(x=Bedroom,y=FullBath)) + geom_jitter() +
  scale_x_continuous(breaks=0:16, minor_breaks=NULL) +
  scale_y_continuous(breaks=0:12, minor_breaks=NULL)
  


# line graph --------------------------------------------------------------


# number of houses built per year
years <- as.data.frame(table(homes$YearBuilt, dnn="YearBuilt"), 
                           stringsAsFactors = FALSE)
str(years)
years$YearBuilt <- as.numeric(years$YearBuilt)

ggplot(years, aes(x=YearBuilt, y=Freq)) + geom_line()

# again we can touch up the scales and labels
ggplot(years, aes(x=YearBuilt, y=Freq)) + geom_line() +
  scale_x_continuous(breaks=seq(1700,2000,50)) +
  labs(x="Number of Homes")


# geom_line() with "group" aesthetic for lines within groups

# Six subjects were given an intravenous injection of indometacin at 11 times,
# and each time plasma concentrations of indometacin was measured.

names(Indometh)
summary(Indometh)

# plot lines for for conc over time for each subject; notice the "group"
# aesthetic
ggplot(Indometh, aes(x=time,y=conc, group=Subject)) +
  geom_line()

# with color
ggplot(Indometh, aes(x=time, y=conc, group=Subject, color=Subject)) +
  geom_line()

# Notice the legend is not in numeric order. That's because Subject is an
# ordered factor.
class(Indometh$Subject)
levels(Indometh$Subject)

# Remember that scales control legends. So to put the legend in numeric order we
# need to use the scale_color_discrete() function. Simply set the limits to
# range from 1 to 6.
ggplot(Indometh, aes(x=time,y=conc,group=Subject, color=Subject)) +
  geom_line() +
  scale_color_discrete(limits=1:6)

# Let's do a quick example of reshaping data and using line graphs with faceting
head(airquality,3)

# Let's reshape airquality so there's one record per day per measure. The melt()
# function from the reshape2 package makes this pretty easy.

# First make a copy of airquality
aq <- airquality

# Next combine the Day and Month columns into one column called date
aq$date <- as.Date(paste("1973",aq$Month, aq$Day,sep="-"))
# Then drop Month and Day columns since we don't need them
aq$Month <- aq$Day <- NULL 
head(aq, 3)

# now we melt the data, ie make it Long. id.vars = "date" means that's the 
# column that remains and identifies a record. The remaining columns are
# "melted".
aqLong <- melt(aq, id.vars = "date")
head(aqLong)

# now we can make line graphs for each value vs. date faceted by variable
ggplot(aqLong, aes(x=date, y=value)) + geom_line() + 
  facet_wrap( ~ variable)

# Notice all four variables are sharing the same size scale. It's probably 
# better to allow the y-axis to vary. The scales = "free_y" argument allows us
# to do that.
ggplot(aqLong, aes(x=date, y=value)) + geom_line() + 
  facet_wrap( ~ variable, scales = "free_y")


# Your Turn!

# The nlme package (that comes with R) has a dataset called Oxboys. These data 
# contain the height of 26 boys from Oxford, England recorded over time (age). 
# Load the data and plot height (y) versus standardized age (x) for each boy
# (Subject). Don't worry about a legend.
data(Oxboys, package = "nlme")
summary(Oxboys)

ggplot(Oxboys, aes(x=age,y=height, group=Subject)) +
  geom_line() 


# bar graph ---------------------------------------------------------------

# bar graphs in ggplot can be a little tricky. By default, it plots a count of 
# items in a category. Technically this is a statistical transformation, 
# stat="bin", which requires your data to have one record per item being
# counted. If your data set already contains counts, you have to specify
# stat="identity".

# Let's do some examples of both scenarios.

# The following data are occurences of cougars in the US. It was downloaded from
# Biodiversity Information Serving Our Nation (BISON),
# http://bison.usgs.ornl.gov.

url <- "http://people.virginia.edu/~jcf2d/workshops/ggplot2/bison-Cougar-20150520-172801.csv"
cougar <- read.csv(url)

# Basis of Record - the type of species occurrence or evidence upon which it is
# based.
summary(cougar$basisOfRecord)

# Let's make a bar graph of that.
ggplot(cougar, aes(x=basisOfRecord)) + geom_bar()

# Easy enough because our data set has one record per occurence.

# What if the data was aggregated, like so:
cougar2 <- as.data.frame(xtabs(~ basisOfRecord, data=cougar))
cougar2

# now try ggplot with geom_bar()
ggplot(cougar2, aes(x=basisOfRecord)) + geom_bar()
# it counted one record each! Not what we wanted.

# We need to change the statistical transformation to stat="identity" and
# specify a y-axis aesthetic.
ggplot(cougar2, aes(x=basisOfRecord, y=Freq)) + geom_bar(stat="identity")

# Notice we could use a dot plot for this graph
ggplot(cougar2, aes(x=Freq, y=basisOfRecord)) + 
  geom_point()

# Perhaps add a line from the point to the y-axis.
ggplot(cougar2, aes(x=Freq, y=basisOfRecord)) + 
  geom_point() +
  geom_segment(aes(xend = 0, yend = basisOfRecord))  +
  labs(y="Basis of Record")



# Your turn!

# Using the cougar data set, create a bar chart of occurences by providedState. 
# Recall each record is an occurence so we just need to make a bar chart of 
# providedState. Hint: add + coord_flip() to rotate your chart and make it look
# nicer.

ggplot(cougar, aes(x=providedState)) + geom_bar() + coord_flip()



# Advanced Topics ---------------------------------------------------------

# saving ggplot graphs
p <- ggplot(iris, aes(x = Petal.Width, y = Petal.Length, color=Species)) + 
  geom_point()

p

# add geoms to saved graph; handy for interactive use; saves typing

p + geom_smooth(method="lm")  
p + geom_smooth(method="lm", se=F)   
p + geom_smooth(method="lm", formula = y ~ poly(x, 3))
p + geom_point(aes(size=Sepal.Width))

# "zoom in" on plot with coord_cartesian()
p + geom_smooth(method="lm", se=F) +
  coord_cartesian(xlim=c(1,2), ylim = c(3, 5))


# add mean to boxplots

# add mean to iris box plots
bp <- ggplot(iris, aes(x=Species, y=Petal.Width)) + geom_boxplot(width=0.5)
bp
# now add means to the plot using stat_summary():
bp + stat_summary(fun.y = mean, geom="point", color="red", size=3)

# add means and CIs to strip chart

# first need to calculate means and standard errors
fMean <- tapply(chickwts$weight, chickwts$feed, mean)
fSE <- tapply(chickwts$weight, chickwts$feed, function(x) sd(x)/sqrt(length(x)))
# now create data frame; recall that ggplot requires data frame
chick2 <- data.frame(feed=names(fMean), fMean, fSE, row.names = NULL)

# now plot strip chart and error bars
# notice we call two data frames
sc <- ggplot(chickwts, aes(x=feed, y=weight)) + 
  geom_point(position = position_jitter(w = 0.1, h = 0))
sc

# now add mean and error bars
sc + geom_point(data=chick2, aes(x=feed, y=fMean), color="#0D3268", size=3) +
  geom_errorbar(data=chick2, aes(x=feed, y=fMean, 
                                 ymin=fMean - 2*fSE, 
                                 ymax=fMean + 2*fSE), 
                width=0.1, color="#F59A2C") +
  labs(title="Mean Weight by Feed Type with 2*SE Bars")

# another way using stat_summary; fun.data="mean_cl_normal" actually calls the 
# function smean.cl.normal() from the Hmisc package. It uses the t distribution
# to determine the multiplier of the standard error.
ggplot(chickwts, aes(x=feed, y=weight)) + 
  geom_point(position = position_jitter(w = 0.1, h = 0)) +
  stat_summary(fun.data="mean_cl_normal", color="#F59A2C", geom="errorbar", width=0.1) +
  stat_summary(fun.y = mean, geom="point", color="#0D3268", size=3)


# single line graph of means at each time point with SE bars

# Recall this plot:
ggplot(Indometh, aes(x=time,y=conc, group=Subject)) +
  geom_line()

# Let's say we wanted to create a single line graph of means at each time point
# with SE bars.

# first calculate means and SEs
tMean <- tapply(Indometh$conc, Indometh$time, mean)
tSE <- tapply(Indometh$conc, Indometh$time, function(x)sd(x)/sqrt(length(x)))

# ggplot requires data in data frame
Indo2 <- data.frame(time=unique(Indometh$time), tMean, tSE, row.names = NULL)

# now ready to create plot
ggplot(Indo2, aes(x=time,y=tMean)) +
  geom_line() +
  geom_errorbar(aes(ymin=tMean-2*tSE, ymax=tMean+2*tSE), width=0.1)

# or again we can use stat_summary()
ggplot(Indometh, aes(x=time,y=conc)) +
  stat_summary(fun.data="mean_cl_normal", geom="errorbar", width=0.1) +
  stat_summary(fun.y = mean, geom="line")

# overlayed histograms with transparency
ggplot(iris, aes(x=Petal.Length, fill=Species)) +
  geom_histogram(position="identity", alpha=0.4, binwidth=.1) 
# position="identity" needed for overlapping; without they get stacked;
# alpha = transparency setting

# maps
library(maps)
library(mapproj) # for the "ployconic" option

states <- map_data("state")
cougar$region <- tolower(cougar$providedState)
cougmap <- merge(states, subset(cougar, !is.na(decimalLongitude)), by = "region")

ggplot(cougmap, aes(long, lat)) +
  borders("state") +
  geom_point(aes(x = decimalLongitude, y=decimalLatitude, color=basisOfRecord)) +
  coord_map("polyconic")

# saving graphs as images

# use ggsave(). It saves the last plot according to your file extension.
ggsave("cougars.jpg", width=10, height=5)



# editing guides (legends) 

# plot Ozone vs. Temp with point color mapped to Month; we have to use the 
# factor() function to ensure Month is treated as a categorical variable.
# Compare the difference:

ggplot(airquality, aes(x=Temp, y=Ozone, color=Month)) + geom_point()
ggplot(airquality, aes(x=Temp, y=Ozone, color=factor(Month))) + geom_point()

# The second plot is what we want, but look at the legend title. How can we fix 
# that? A discrete factor (Month) is mapped to color, so we need to change the 
# properties of the color scale. Therefore we use the scale_color_discrete() 
# function. NOTE: month.name is a built-in R function that contains names of
# months in a vector. Below I extract the months numbered 5 - 9.

ggplot(airquality, aes(x=Temp, y=Ozone, color=factor(Month))) + geom_point() +
  scale_color_discrete(name = "Month", labels=month.name[5:9])



# Themes

# Using built-in themes such as theme_bw()
# Before
ggplot(airquality, aes(x=Temp)) + geom_histogram(binwidth=2) +
  facet_wrap(~Month)
# After
ggplot(airquality, aes(x=Temp)) + geom_histogram(binwidth=2) +
  facet_wrap(~Month) + theme_bw()

# To permanently change the theme:
prevTheme <- theme_set(theme_bw())

ggplot(airquality, aes(x=Temp)) + geom_histogram(binwidth=2) +
  facet_wrap(~Month)

ggplot(airquality, aes(x=Temp)) + geom_freqpoly(binwidth=2) +
  facet_wrap(~Month)

# To restore
theme_set(prevTheme)
# verify
ggplot(airquality, aes(x=Temp)) + geom_freqpoly(binwidth=2) +
  facet_wrap(~Month)


# Multiple plots in one window

# In base R, we usually use par(mfrow=c(i,j)), like so:
par(mfrow=c(1,2))
hist(airquality$Temp, main="Distribution of Temp", xlab="Temp")
plot(Ozone ~ Temp, data=airquality, main="Ozone vs. Temp")
par(mfrow=c(1,1))

# We cannot use this approach for ggplot2. The easiest solution is to use the 
# grid.arrange() function in the gridExtra package. To use it, you have to save
# your plots and then call them using grid.arrange().

p1 <- ggplot(airquality, aes(x=Temp)) + geom_histogram(binwidth=4.5) + 
  labs(title="Distribution of Temp")
p2 <- ggplot(airquality, aes(x=Temp, y=Ozone)) + geom_point() +
  labs(title="Ozone vs. Temp")
library(gridExtra)
grid.arrange(p1, p2, nrow=1) # can also use ncol



